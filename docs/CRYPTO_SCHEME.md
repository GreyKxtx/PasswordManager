# Схема криптографии и управления ключами

## Выбранная архитектура

В прототипе реализована схема с **отдельным Vault Key**, зашифрованным ключом, выведенным из мастер-пароля.

## 1. Управление ключами

### Схема: VaultKey + PasswordKey

**VaultKey** (256-битный случайный ключ):
- Генерируется один раз при регистрации пользователя
- Используется для шифрования/расшифровки всех записей хранилища
- Хранится в БД в зашифрованном виде (`vaultKeyEnc`)
- Никогда не хранится в открытом виде на сервере

**PasswordKey** (ключ, выведенный из мастер-пароля):
- Выводится из мастер-пароля через Argon2id на клиенте
- Используется для шифрования/расшифровки VaultKey
- Никогда не отправляется на сервер
- Хранится только в памяти клиента

**PasswordVerifier** (проверочный элемент):
- Выводится из PasswordKey (или мастер-пароля) через дополнительный проход KDF
- Отправляется на сервер для проверки пароля
- Хранится в БД в поле `passwordVerifier`

### Структура данных в БД (users)

```typescript
{
  email: string;                    // Уникальный email
  passwordVerifier: string;         // Argon2id hash для проверки пароля
  kdfParams: {                     // Параметры KDF (для совместимости)
    algorithm: 'argon2id';
    memory: number;
    iterations: number;
    parallelism: number;
    salt: string;                   // base64
  };
  vaultKeyEnc: string;              // VaultKey, зашифрованный PasswordKey (base64)
  vaultKeyEncIV: string;             // IV для шифрования VaultKey (base64)
  twoFactorEnabled: boolean;
  totpSecretEnc?: string;            // TOTP секрет, зашифрованный VaultKey
  webauthnCredentials?: Array<...>;
  createdAt: Date;
}
```

## 2. Процесс регистрации

1. **Клиент**:
   - Пользователь вводит email и мастер-пароль
   - Генерируется случайная соль (16 байт)
   - Выполняется Argon2id KDF от мастер-пароля → получается `passwordKey` (32 байта)
   - Выполняется дополнительный проход Argon2id от `passwordKey` → получается `passwordVerifier`
   - Генерируется случайный `vaultKey` (32 байта)
   - Шифруется `vaultKey` с помощью `passwordKey` (AES-256-GCM) → `vaultKeyEnc`
   - Отправляется на сервер: `email`, `passwordVerifier`, `kdfParams`, `vaultKeyEnc`, `vaultKeyEncIV`

2. **Сервер**:
   - Проверяет уникальность email
   - Сохраняет `passwordVerifier`, `kdfParams`, `vaultKeyEnc`, `vaultKeyEncIV` в БД
   - Генерирует JWT токены
   - Возвращает токены клиенту

**Важно**: Мастер-пароль и `passwordKey` никогда не отправляются на сервер.

## 3. Процесс входа

1. **Клиент**:
   - Пользователь вводит email и мастер-пароль
   - Загружает `kdfParams` с сервера (или использует сохраненные)
   - Выполняет Argon2id KDF от мастер-пароля с теми же параметрами → `passwordKey`
   - Выполняет дополнительный проход Argon2id → `passwordVerifier`
   - Отправляет на сервер: `email`, `passwordVerifier`

2. **Сервер**:
   - Находит пользователя по email
   - Сравнивает полученный `passwordVerifier` с сохраненным (timing-safe сравнение)
   - Если совпадает:
     - Генерирует JWT токены
     - Создает запись сессии
     - Возвращает токены и `vaultKeyEnc`, `vaultKeyEncIV` клиенту

3. **Клиент** (после успешной аутентификации):
   - Расшифровывает `vaultKeyEnc` с помощью `passwordKey` → получает `vaultKey`
   - Сохраняет `vaultKey` в памяти
   - Использует `vaultKey` для всех операций с хранилищем

**Важно**: `vaultKey` хранится только в памяти и очищается при логауте.

## 4. Шифрование записей хранилища

Каждая запись шифруется отдельно с использованием `vaultKey`:

1. **Создание записи**:
   - Клиент формирует объект записи (title, login, password, note, etc.)
   - Сериализует в JSON
   - Шифрует с помощью AES-256-GCM и `vaultKey`
   - Отправляет зашифрованные данные на сервер

2. **Чтение записи**:
   - Сервер возвращает зашифрованные данные
   - Клиент расшифровывает с помощью `vaultKey`
   - Отображает расшифрованные данные

**Важно**: Сервер никогда не видит незашифрованные данные записей.

## 5. Смена мастер-пароля

1. **Клиент**:
   - Пользователь вводит старый и новый мастер-пароль
   - Выполняет KDF от старого пароля → `oldPasswordKey`
   - Расшифровывает `vaultKeyEnc` → получает `vaultKey`
   - Выполняет KDF от нового пароля → `newPasswordKey`
   - Шифрует `vaultKey` с помощью `newPasswordKey` → новый `vaultKeyEnc`
   - Выполняет дополнительный проход KDF → новый `passwordVerifier`
   - Отправляет на сервер: новый `passwordVerifier`, новый `vaultKeyEnc`, новый `vaultKeyEncIV`

2. **Сервер**:
   - Обновляет `passwordVerifier`, `vaultKeyEnc`, `vaultKeyEncIV`
   - Инвалидирует все сессии, кроме текущей
   - Возвращает подтверждение

**Важно**: Записи хранилища не перешифровываются, так как `vaultKey` не меняется.

## 6. Преимущества выбранной схемы

1. **Безопасность**: Мастер-пароль никогда не отправляется на сервер
2. **Гибкость**: Смена мастер-пароля не требует перешифрования всех записей
3. **Производительность**: KDF выполняется только при входе, не при каждой операции
4. **Совместимость**: Легко изменить параметры KDF для конкретного пользователя

## 7. Криптографические параметры

- **KDF**: Argon2id
  - Memory: 19 МБ (19456 KB)
  - Iterations: 2
  - Parallelism: 1
  - Salt: 16 байт (128 бит)

- **Шифрование**: AES-256-GCM
  - Key length: 256 бит (32 байта)
  - IV length: 96 бит (12 байт)
  - Tag length: 128 бит

- **Генерация случайных**: 
  - Клиент: `crypto.getRandomValues()`
  - Сервер: `crypto.randomBytes()`

