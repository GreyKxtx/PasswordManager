ТЗ

Разрабатываемая система называется «Безопасный облачный менеджер паролей с сквозным шифрованием и аутентификацией пользователя» – обеспечение безопасного хранения и управления паролями пользователей в облаке с использованием сквозного шифрования (End-to-End Encryption, E2EE) и надежных методов аутентификации.

1. Краткое описание назначения системы
Система предназначена для защищенного хранения учетных данных (паролей, логинов, заметок и других конфиденциальных данных) пользователей на удаленном сервере с синхронизацией между устройствами. Ключевая особенность – применение сквозного шифрования: вся конфиденциальная информация шифруется на стороне клиента перед отправкой в облако и недоступна в открытом виде даже для сервера. Система обеспечивает удобное управление паролями, автоматическое заполнение данных авторизации на веб-сайтах и поддерживает современные методы двухфакторной и аппаратной аутентификации для повышения безопасности.
2. Функциональные требования к системе
2.1. Регистрация и аутентификация пользователя
2.1.1. Создание учетной записи (регистрация). Система должна предоставлять пользователям возможность регистрации нового аккаунта. При регистрации пользователь задаёт уникальные учетные данные – как минимум адрес электронной почты (или иной идентификатор логина) и мастер-пароль. Мастер-пароль будет использоваться в дальнейшем как главный секрет для доступа к хранилищу паролей. При создании аккаунта выполняются следующие проверки и действия: 
- Проверка уникальности: Система проверяет, что указанный email (или логин) еще не используется другим аккаунтом. В противном случае регистрация отклоняется с соответствующим уведомлением. 
- Валидация пароля: Проводится оценка сложности мастер-пароля. Должны быть заданы минимальные требования (например, длина не менее 12 символов, наличие букв разного регистра, цифр и спецсимволов). Если пароль слишком простой или найден в списках скомпрометированных, система предупреждает пользователя и требует усилить пароль. 
- Генерация криптографической основы: На стороне клиента, при успешном вводе мастер-пароля, будет сгенерирован криптографический ключ (или несколько ключей) на основе этого пароля. На этапе регистрации может генерироваться, к примеру, master key – главный симметричный ключ для шифрования данных, и/или клю́ч аутентификации – дериват от пароля, предназначенный для проверки при входе.
- Сохранение данных на сервере: На сервер передаются данные, необходимые для аутентификации в будущем и для идентификации пользователя. Важно: сам мастер-пароль ни в каком виде не пересылается и не хранится на сервере. Вместо него сохраняется только криптографический проверочный элемент – например, соль и хеш от мастер-пароля. Также создается запись профиля пользователя (ID, email, время регистрации и пр.). Если используются аппаратные ключи или 2FA при регистрации, происходит их привязка. 
- Подтверждение регистрации: В базовой версии, сразу после успешного ввода данных, аккаунт считается созданным. При желании можно предусмотреть подтверждение email (высылая ссылку), но это относится скорее к дополнительным мерам. В рамках текущего ТЗ можно опустить обязательное подтверждение почты, но оставить возможность его реализации.
2.1.2. Вход в систему (авторизация). Реализуется механизм безопасной аутентификации зарегистрированных пользователей: 
- Ввод учетных данных: Пользователь вводит свой логин (email) и мастер-пароль на странице входа. 
- Проверка учетных данных: На сервере по логину находится соответствующая учетная запись. Проверка пароля производится следующим образом: пароль, введенный пользователем, не отправляется в открытом виде – вместо этого клиентская часть вычисляет от него некоторый проверочный токен и отправляет на сервер. Сервер сравнивает полученный проверочный элемент с хранимым значением (например, сравнивает хеши). Если они совпадают, считается, что мастер-пароль верный, и аутентификация успешна. Если нет – сервер возвращает ошибку. В целях защиты от перебора паролей должны быть предусмотрены ограничения (например, блокировка или увеличение задержки после нескольких неудачных попыток входа). 
- Создание сессии: При успешном входе сервер инициирует пользовательскую сессию. Используется безопасный механизм сессий – например, JWT-токены (в паре: access token с коротким сроком и refresh token с более длинным) либо классическая серверная сессия с идентификатором, сохраняемым в защищенном cookie (HttpOnly, Secure). В ТЗ допускаются оба подхода, но предпочтителен JWT для масштабируемости. Сессия связывается с устройством: сохраняется информация о входе (в БД – deviceID, последние IP, время). 
- Двухфакторная авторизация (если включена): Если для учетной записи пользователя настроена 2FA, то после ввода правильного пароля требуется дополнительный шаг. Это может быть ввод одноразового кода (TOTP из приложения-аутентификатора или полученного по email/SMS) либо подтверждение через WebAuthn токен. Система запрашивает второй фактор и проверяет его: для TOTP – сверяет код с генерируемым по секретному ключу (хранящемуся у пользователя или на сервере в зашифрованном виде), для WebAuthn – проводит соответствующий вызыв API (navigator.credentials.get) и проверку подписанного ответа на сервере. При успешной 2FA аутентификации сессия помечается как доверенная. 
- Управление сессиями: После входа пользователь получает доступ к функционалу приложения и может работать со своим зашифрованным хранилищем. Система должна обеспечивать управление сессией: возможность выхода (logout) по требованию пользователя, автоматическое истечение сессии по тайм-ауту бездействия, а также отзыв токенов. При логауте активный токен сессии помечается недействительным (например, в случае JWT – вносим в черный список до истечения его срока, или удаляем серверную сессию). 
2.1.4. Поддержка двуфакторной аутентификации. Система должна позволять пользователю включить 2FA для своей учетной записи: 
- TOTP: Генерация секретного ключа для Time-based One-Time Password (например, алгоритм HOTP/TOTP RFC 6238). Пользователю отображается QR-код для добавления в приложение типа Google Authenticator. С этого момента при каждом входе будет требоваться 6-значный (или 8-значный) код, генерируемый приложением. Сервер хранит TOTP-секрет в базе данных, зашифрованный на мастер-ключ пользователя. Проверка кода производится на сервере с использованием стандартных библиотек, допускается отклонение по времени ±30 сек. 
- Режимы 2FA: В TЗ предполагается поддержка 2FA как дополнительного шага. 
2.2. Сквозное шифрование
Система должна гарантировать, что все чувствительные данные, хранящиеся в хранилище паролей, никогда не передаются и не хранятся в незашифрованном виде на сервере.
2.2.1. Генерация криптографических ключей на клиенте. При регистрации нового пользователя (а также при входе, с использованием его мастер-пароля) на стороне клиента (в браузере) должны быть сгенерированы необходимые криптографические ключи: 
- Master Key (ключ шифрования хранилища): основной симметричный ключ, который будет использоваться для шифрования и расшифровки данных в хранилище паролей. Он либо напрямую выводится из мастер-пароля пользователя, либо генерируется случайно и затем защищается производным от пароля ключом (см. далее о выборе схемы). 
- Authentication Key / Verification Hash: элемент, позволяющий серверу выполнять проверку введенного пароля без знания самого пароля. Это может быть криптографический хеш мастер-пароля или ключа, полученного из него (например, хранится Argon2-hash от пароля).
Все генерации выполняются с использованием криптографически стойкого генератора случайных чисел. В браузере – это API crypto.getRandomValues() (гарантирует крипто-стойкость), на сервере (если вдруг надо) – crypto.randomBytes Node.js. Размеры ключей: симметричные ключи не менее 256 бит (32 байта) для алгоритмов AES.
2.2.2. Выведение ключа из мастер-пароля (KDF). Для получения криптографического ключа из пароля пользователя применяется функция выработки ключа из пароля (KDF) с усилением против перебора.: 
Применение KDF: когда пользователь вводит мастер-пароль (при регистрации или входе), на клиенте выполняется KDF с указанными параметрами, полученный ключ далее используется: 
- как Master Key для шифрования (если напрямую) или для расшифровки Vault Key; 
- частично (или через другой проход KDF) – для формирования проверочного хеша, хранимого на сервере.
2.2.3. Шифрование и расшифровка записей на клиенте. Все операции добавления, просмотра или изменения данных в хранилище паролей происходят с шифрованием/дешифрованием на стороне клиента (в браузере или расширении): 
- Алгоритмы шифрования: Предпочтительно использовать современные схемы аутентифицированного шифрования. Например, AES-256-GCM (режим AES с 256-битным ключом и встроенной аутентификацией Galois/Counter Mode). 
- Шифрование записей: Каждая запись (запись – это, например, один “логин-пароль” вместе с примечанием и прочими полями) шифруется отдельно. 
- Расшифровка: Когда пользователь запрашивает данные (например, открывает свой список паролей), сервер отправляет шифрованные данные, а клиент расшифровывает их, используя ключ, который есть только у клиента (Master Key или Vault Key). Только после успешной аутентификации и выполнения KDF на клиенте у него появляется ключ для расшифровки. В памяти клиента хранятся расшифрованные данные, которые используются в интерфейсе. 
2.3. Работа с хранилищем паролей (Vault)
Хранилище паролей (vault) – это логическая структура, принадлежащая пользователю, в которой хранятся записи с его учетными данными и связанными секретами.
2.3.1. Создание, редактирование и удаление записей. Пользователь после входа может управлять своими записями:
- Создание новой записи: Через интерфейс пользователь может добавить новую запись, указав необходимые поля – обычно это “Название” (или привязка к конкретному ресурсу, например, “Facebook аккаунт”),  заметка или дополнительные поля (например, URL веб-сайта, номер счета, PIN-код и т.д.). Система должна позволять произвольное количество дополнительных полей или хотя бы иметь фиксированный набор наиболее употребимых. При сохранении запись шифруется на клиенте (все чувствительные поля – как минимум пароль, заметка, PIN – точно шифруются). Генерируется уникальный идентификатор записи (может быть UUID или ObjectId в MongoDB). 
- Редактирование записи: Пользователь может в любой момент изменить информацию в существующей записи (например, обновить пароль на новый). Операция редактирования предполагает: загрузить текущие данные, внести изменения, затем снова зашифровать и отправить на сервер для замены старых данных. 
- Удаление записи: Пользователь может удалить ненужную запись. В системе должна быть реализована операция удаления, которая удаляет запись из базы данных. Простое удаление означает, что запись стирается навсегда, включая все ее версии.
2.3.2. Организация записей: группировка, теги, поиск, фильтрация. Для удобства пользования хранилищем
 - Группировка/Каталогизация: Система может предоставлять возможность объединять записи в папки или помечать их тегами. Например, пользователь может создать папку "Работа" и "Личное" и распределить пароли соответствующим образом. Или присвоить тег "почта" нескольким записям. 
- Поиск: Пользовательский интерфейс должен позволять поиск по записям. Поисковый запрос может сопоставляться с названием записи, логином или другими полями. Например, при вводе "gmail" должны находиться записи, где в названии или логине есть "gmail".
2.4. Синхронизация и многопристроевой доступ
Поскольку система облачная, одной из ключевых ее функций является синхронизация данных между устройствами пользователя.
2.4.1. Механизм синхронизации между клиентами. Требования к синхронизации:
- Запросы обновлений: Простейший подход – периодическое опрос (polling). Например, клиент при активном открытом приложении делает запрос к серверу раз в N минут или при определенных событиях для получения списка изменений. 
2.5. Резервное копирование и восстановление
Чтобы повысить надежность хранения и дать пользователю больше контроля, система должна иметь функции резервирования данных на стороне пользователя.
2.5.1. Экспорт (резервное копирование) хранилища. Пользователь может создать резервную копию всего своего хранилища паролей: 
- Формат бэкапа: Предлагается экспортировать зашифрованный файл, который пользователь может сохранить локально. Формат может быть, например, JSON с зашифрованными записями либо собственный двоичный формат. Важный момент: файл должен быть защищен тем же мастер-ключом или паролем, чтобы в случае его компрометации без пароля он был бесполезен. То есть, внутри файла может лежать все содержимое в зашифрованном виде. 
- Процесс экспорта: Пользователь в интерфейсе нажимает "Экспортировать данные". Клиентское приложение собирает все записи из локального хранилища (или запрашивает актуальные с сервера), затем шифрует их. Полученный блок данных предлагается скачать как файл. 
2.5.2. Импорт (восстановление из резервной копии). Пользователь, имея файл резервной копии, должен иметь возможность загрузить его в систему для восстановления данных:
- Процесс импорта: Пользователь заходит в интерфейс  и выбирает "Восстановить из резервной копии". Ему предлагается выбрать файл. Далее: 
- Если бэкап защищен отдельным паролем, запросить этот пароль. 
- Клиент загружает файл (не отправляя его на сервер!) и пытается его расшифровать (используя либо текущий мастер-пароль, либо введенный пароль бэкапа).
 - Эти записи затем отправляются на сервер (зашифрованные мастер-ключом пользователя) для воссоздания хранилища.
2.6. Управление устройствами и сессиями
Для повышения контроля безопасности пользователь должен иметь возможность просматривать и управлять активными сессиями (входами) и связанными устройствами.
2.6.1. Просмотр активных сессий/устройств. В личном кабинете или настройках безопасности должна быть страница "Мои устройства" или "Активные сессии". 
- Каждый элемент списка может включать: название устройства или браузера, IP-адрес и геолокация (грубо) входа, время последней активности, флаг текущей сессии.
- Информация должна храниться на сервере при каждом успешном входе (создается запись сессии с токеном/ID, данными устройства).
2.6.2. Завершение сессий (Logout Remote). Пользователь должен иметь возможность принудительно завершить любую из активных сессий: - Например, если он потерял устройство или видит неизвестную сессию, он нажимает "Завершить" рядом с ней. Сервер, получив такой запрос, помечает соответствующую сессию как закрытую: удаляет/инвалидирует токен. 
2.7. Дополнительные функциональные возможности
В качестве отличительных и современных черт системы выделены следующие компоненты: браузерное расширение для автозаполнения и поддержка современных методов аутентификации. Эти функции описаны детально ниже.
2.7.1. Браузерное расширение (Chrome / Firefox)
Система должна включать разработку браузерного расширения, интегрированного с основным приложением и облегчающего использование менеджера паролей в повседневной работе пользователя. Требования к расширению:
2.7.1.1. Автоматическое заполнение полей логина/пароля. Расширение должно уметь определить, что на загруженной странице есть форма входа (как правило, поля <input type="password"> и, возможно, поле логина) и предложить пользователю заполнить ее сохраненными данными: 
- Если сайт (домен) соответствует одному из записанных в хранилище расширение может автоматически подставить логин и пароль в соответствующие поля. 
- Следует предусмотреть механику разблокировки: так как расширение не должно держать пароли открытыми постоянно, при первом автозаполнении за сессию может потребоваться ввод мастер-пароля или разблокировка расширения (например, PIN или биометрия, если поддерживается).
- Также, вместо автоматического сразу, можно сделать по клику: пользователь кликает в поле и видит иконку расширения, по которой вызывается заполнение.
2.7.1.2. Виявление форм логина. Расширение должно надежно распознавать формы аутентификации:
- Помимо просто наличия поля типа "password", желательно проверить, что рядом есть поле для логина (email/username), чтобы корректно заполнить.
- У некоторых сайтов поля могут иметь нестандартные атрибуты, поэтому можно использовать Heuristics: например, ищем <input type=password> и поле <input> с именем/id, содержащим “user”, “email”, “login” и т.п
- Кроме того, расширение может предлагать сохранить новый пароль: когда пользователь сам регистрируется на сайте и вводит новый пароль, расширение замечает отправку формы с паролем и предлагает сохранить эти данные в менеджер.
2.7.1.3. Интеграция с основным бекендом и хранилищем (API). Расширение фактически является легковесным клиентом, работающим через тот же API сервера: 
- При первом использовании расширения пользователь должен войти в свой аккаунт (ввести мастер-пароль, пройти 2FA). Расширение отправляет эти данные к серверу (по защищенному каналу), получает токен аутентификации (JWT или сессионный). 
- Далее расширение может напрямую вызывать REST API бекенда: например, чтобы получить все записи (/vault/items) или отдельную запись, или обновить запись, если пользователь сохраняет через расширение.
- Важно: расширение работает, даже если веб-приложение не открыто, поэтому весь необходимый функционал оно делает само.
- Безопасность API: надо убедиться, что запросы из расширения авторизованы, а сам API разрешает кросс-доменные обращения (расширение может обращаться к https://наш-домен/api/... вне контекста страничного JS, поэтому CORS должен быть настроен соответствующе).
3. Нефункциональные требования
3.1. Портативность и кросс-браузерность
•	Установка и обновление: Расширение должно быть портировано под соответствующие магазины (Chrome Web Store, AMO for Firefox). Веб-приложение – PWA (прогрессивное веб-приложение) можно рассмотреть.
•	Интеграция с ОС: При желании, можно чтобы веб-версия поддерживала OS-specific API, например, Clipboard API (для копирования паролей)
3.2. Вимоги до криптографічних алгоритмів (Требования к криптографическим алгоритмам)
На основе угроз выдвигаются строгие требования к используемым криптопримитивам:
•	Алгоритм хеширования паролей/KDF: Должен быть использован алгоритм, специально предназначенный для защиты паролей от перебора. Как обсуждалось, выбран Argon2id – современный стандарт.
Требование: Argon2id настроен с параметрами не ниже минимальных рекомендаций OWASP (например, ~19 МБ памяти, 2+ итерации) и проверено, что такое вычисление занимает не менее 0.05-0.1 секунды на типовом оборудовании – чтобы атаки перебора замедлить тысячекратно. 
Симметричное шифрование: Для шифрования данных в хранилище применяется алгоритм AES с длиной ключа 256 бит
•	Генерация случайных чисел: Везде, где требуются случайные данные (соли, IV, ключи, OTP секреты), они должны генерироваться криптографически стойким генератором. Никаких Math.random().
- На клиенте: window.crypto.getRandomValues() – соответствует требованиям, генерирует высококачественные случайные.
- На сервере: crypto.randomBytes() или os.urandom.
- Длины: соль для KDF не менее 128 бит (16 байт) – этого достаточно, чтобы исключить совпадения и сделать rainbow-tables невозможными. IV 96 бит (GCM requirement). OTP секреты – обычно 160 бит (для TOTP).
•	Алгоритмы для 2FA:
- TOTP реализуется на SHA-1 или SHA-256. В принципе, можно SHA-256, но большинство приложений OTP ожидают SHA-1, поэтому примем стандарт.
- WebAuthn – использует асимметричные алгоритмы, обычно ECDSA или EdDSA (например, ключи P-256, Ed25519) либо RSA 2048+. Будем следовать библиотекам: большинство ключей безопасности – ECDSA P-256.
•	Алгоритмы хеширования и HMAC:
•	В приложении может использоваться HMAC для каких-то целей (например, подпись JWT – HMAC SHA-256, или HMAC-based HKDF). Требование: ключи для HMAC должны быть достаточно длинными (256 бит) и функции – SHA-256 или лучше.
•	Длины ключей и параметры:
•	Симметричные ключи: 256 бит (32 байта).
•	Асимметричные: ECDSA P-256 (ключ ~256 бит координаты, но эквивалент безопасности ~128-bit symmetric). Этого достаточно. Можно также Ed25519. RSA, если, – минимум 2048, лучше 3072, но RSA не столь удобен.
•	Nonce/IV: 12 байт (96 бит) для AEAD.
•	Salt: >=16 байт, уникальная на каждого пользователя (и на каждую смену пароля – если меняется пароль, новая соль).
3.3. Управление ключами
Ключевая задача безопасности – правильно управлять криптографическими ключами в течение их жизненного цикла (генерация, хранение, использование, уничтожение): 
- Хранение ключей на клиенте: Как указано ранее, мастер-ключ и производные ключи хранятся только на клиентской стороне. В контексте веб-приложения это означает:
- В памяти JavaScript (переменные), возможно – в IndexedDB или sessionStorage (зашифрованном виде) для кэша. Нужно исключить запись секретов в localStorage без шифрования, т.к. он доступен долго и потенциально другим скриптам.
- Лучше, после ввода пароля, держать ключи в памяти (JS Heap) и при логауте или закрытии вкладки – очищать. 
- Для расширения: хранение ключа возможно в background script (пока расширение активно) или в Session storage extension. Некоторые расширения применяют Vault, защищенный OS. В нашем проекте – хранение аналогично веб: в памяти, optional – в chrome.storage.session (которая очищается при перезапуске). 
- Избежание постоянного хранения: Мастер-пароль нигде не сохраняется. Если пользователь закрыл приложение, при повторном открытии нужно вводить пароль снова. В браузере можно предложить "запомнить пароль" используя защищенное хранилище ОС. 
- Смена мастер-пароля: Необходимо предусмотреть процесс изменения мастер-пароля: - Пользователь, будучи залогиненым, выбирает "сменить мастер-пароль". Система запрашивает старый пароль (для подтверждения) и новый пароль. 
- После ввода нового пароля, на клиенте выполняется: деривация нового ключа (New Master Key) с помощью KDF от нового пароля; затем перешифрование всех данных хранилища под новым ключом.: 
- Все активные сессии, кроме текущей, следует инвалидировать (потому что старый пароль уже недействителен, и если кто-то был залогинен, нужно повторно залогиниться под новым). 
- Уничтожение ключей: При логауте, смене пользователя, истечении сессии – все копии секретных ключей должны быть очищены из памяти
- Ключи для сессий: JWT-секреты (подписи токенов) хранятся на сервере (в памяти или конфиге). Доступ к ним – только у приложения. 
3.5. Захист мережевої взаємодії (Защита сетевого взаимодействия)
- HSTS: Включить заголовок Strict-Transport-Security для домена, чтобы браузеры запоминали переход только на HTTPS и предупреждали о попытках MITM с понижением до HTTP
 - Secure cookies: Если используются cookies для сессий, они должны быть помечены Secure (отправляются только по HTTPS) и HttpOnly (недоступны JS, чтобы XSS не стащил).
- Взаимодействие API: Формат JSON. Надо убедиться, что нет утечек в GET-параметрах. Использовать POST для передачи данных. Например, нельзя передавать мастер-пароль или токены в URL. 
- Защита API от повторов: Использование TLS уже дает защиту от перехвата сессии. Но на уровне API можно добавить Replay nonce или использовать встроенные механизмы JWT. 
- Throttling: Сетевая защита включает и ограничение скорости запросов: например, не позволять одному IP сделать >X регистраций в минуту, >Y login попыток. Это предотвратит как brute-force, так и DoS. 
3.6. Захист від web-атак (Защита от веб-атак)
- Clickjacking: - Установить заголовок X-Frame-Options: DENY (или SAMEORIGIN, но DENY надежнее, мы не планируем разрешать встраивать). Это предотвратит отображение нашего приложения внутри iframe на другом домене. - CSP frame-ancestors 'none' – аналогично. 
- Безопасные заголовки: 
- Content Security Policy (CSP) – описано, должен быть.
- X-Content-Type-Options: nosniff – чтобы браузер не пытался интерпретировать ресурсы не по заявленному MIME. В нашем случае API JSON, можно это добавить. 
- Referrer-Policy: лучше strict-origin-when-cross-origin – чтобы на внешние сайты не утекал полный путь (например, если юзер кликнет на ссылке в приложении). 
- Feature Policy / Permissions Policy: можно отключить нам не нужные фичи: геолокацию, камеры и пр. – Permissions-Policy: camera=(), microphone=(), geolocation=() – мало ли. 
- X-XSS-Protection: устарел (браузеры отказываются), CSP лучше. 
- X-Permitted-Cross-Domain-Policies: none – чтобы PDF/Flash (уже нет) не запрашивали policy. 
- HSTS – упоминали. В общем, best practices HTTP headers. 
- Validation: Все входные данные (не только для БД) должны быть проверены на корректность и соответствие типу: 
- Email – regex, длина.
- Пароль – на сложность (но это функционально). 
- Любые поля записи (название, логин, URL) – ограничить разумную длину (например, не больше 1000 символов, чтобы не хранить мегабайты и не допустить потенциальную атаку на длине). 
- На сервере можно использовать библиотеку Joi или схему Mongoose для валидации. 
- Rate limit: Упомянуто, повторю: защита от brute-force тоже относится к веб-уровню – лимит логинов по IP, капча если много попыток, etc. 
4. Архітектура системи (Архитектура системы)
Архитектура системы построена по классической модели клиент-сервер с выделением отдельных подсистем: фронтенд (Angular SPA), бекенд (Node.js/Express API), база данных (MongoDB) и дополнительный компонент – браузерное расширение. 
4.1. Загальна архітектура (Общая архитектура)
Система состоит из следующих основных частей: 
- Клиентское приложение (Web-клиент): Одностраничное веб-приложение, написанное на Angular. Выполняется в браузере пользователя. Этот компонент отвечает за интерфейс (UI/UX), взаимодействие с пользователем, выполнение криптографических операций на стороне клиента (генерация ключей, шифрование/дешифрование) и обращение к серверному API для получения/отправки данных. 
- Серверное приложение (Backend): Построено на Node.js с использованием фреймворка Express. Сервер предоставляет RESTful API для всех необходимых действий – регистрация, логин, операции с хранилищем паролей, и т.д. Логика сервера: аутентификация запросов (проверка JWT или сессии), базовые проверки (например, права доступа – пользователь может смотреть только свои записи), обработка данных и взаимодействие с базой данных. Сервер также осуществляет отдельные функции, такие как отправка email (например, OTP, если реализовано), ведение логов. 
- База данных (MongoDB): СУБД NoSQL, где хранятся все постоянные данные системы: учетные записи пользователей, зашифрованные записи vault, и прочие коллекции (сессии, версии записей, журнал аудита). MongoDB выбрана за её схожесть структуры с JSON, что удобно для хранения объектов записей, а также за гибкость при изменении схемы (важно в исследовательском проекте). В конфигурации по умолчанию будет использоваться одна база, но архитектура допускает масштабирование (шардинг, репликация). 
- Браузерное расширение Расширение (для Chrome/Firefox) интегрируется с браузером, имеет фоновый процесс (background script) и контент-скрипты, взаимодействующие со страницами. Оно общается с тем же backend API, что и SPA, и может рассматриваться как "дополнительный клиент" системы, с акцентом на автозаполнение и интеграцию в сторонние сайты.

Взаимодействие компонентов: 
1. Пользователь открывает веб-приложение (например, по URL сервиса). Angular SPA загружается из веб-сервера (статические файлы Angular сжатые, обычно тоже отдаёт Node.js или CDN).
 2. Пользователь выполняет вход: SPA обращается к backend API (POST /auth/login) с учетными данными. Сервер проверяет, отвечает токеном. Клиент сохраняет токен (в памяти или cookie). 
3. Далее SPA запрашивает данные (например, GET /vault/items), сервер читает из MongoDB коллекцию записей, возвращает зашифрованные данные. SPA расшифровывает их и отображает пользователю. 
4. При создании/редактировании записи: SPA шифрует на клиенте и отправляет POST/PUT /vault/items с шифротекстом. Сервер сохраняет в базу, возможно, добавляет метаданные (время, id). 
5. Расширение браузера при необходимости делает те же запросы: например, при автозаполнении оно может сразу иметь необходимую запись (если ранее все загрузило) либо дернуть API.
 6. Административные или служебные операции могут выполняться отдельными сервисами, но в нашем случае, вероятно, backend сам будет писать логи и статусы.
Где что шифруется: 
- На клиенте: генерация мастер-ключа (KDF), шифрование/расшифровка паролей и записей. Все секреты шифруются до отправки.
- На сервере: шифрования/расшифровки пользовательских данных не производится. Сервер лишь принимает уже зашифрованные данные и возвращает их.
- В базе: данные хранятся преимущественно в зашифрованном виде. Сервер может шифровать некоторые служебные вещи перед сохранением (например, если храним refresh-токены JWT, их можно зашифровать симметрично, чтобы при утечке базы их нельзя было использовать; но это уже вторично).
- В браузерном расширении: аналогично SPA, оно может при запуске либо получить расшифрованные данные от SPA (при совместной работе) либо само их расшифровать (если хранит ключ). 
4.2. Основные компоненты та їх призначення (Основные компоненты и их назначение)
4.2.1. Angular-клиент (SPA): - Построен как Single Page Application. Основные модули/сервисы: 
- Модуль Аутентификации (AuthModule): включает компоненты для Login, Register, possibly 2FA prompt, и сервис AuthService. AuthService управляет токенами: хранит JWT access token, refresh token, осуществляет их обновление. Он же – интерфейс для логина/разлогина (отправляет запросы /auth/*). 
- CryptoService: служба, инкапсулирующая все операции криптографии на клиенте. Например, методы: deriveKeyFromPassword(password), encryptData(plaintext, key), decryptData(ciphertext, key). Может использовать Web Crypto API (window.crypto.subtle), либо JS-имплементации (Argon2). CryptoService также отвечает за генерацию новых случайных паролей (для функции "сгенерировать пароль" пользователю). 
- VaultService: отвечает за взаимодействие с хранилищем. Он, вероятно, обертка над HTTP запросами к /vault эндпоинтам. Например, getAllItems() – делает GET запрос, получает массив зашифрованных записей, расшифровывает через CryptoService, кэширует локально (в state). addItem(item) – шифрует поля и отправляет POST, после ответа добавляет в локальный список. VaultService обеспечивает, чтобы UI всегда работал с расшифрованными объектами, не дублируя код крипто в компонентах. Возможно, VaultService будет хранить state (например, через BehaviorSubject, а компоненты подпишутся).
- Components: - VaultListComponent – отображает список записей (название, может логин, частично скрытый пароль?). Он получает данные из VaultService (подписывается на изменения).
- VaultItemComponent (детали записи, просмотр или редактирование). - EditItemComponent (форма для создания/редактирования).
- SettingsComponent – настройки аккаунта (2FA, devices list). - ExtensionIntegrationComponent (возможно, страница с инструкцией по установке расширения, и pairing, но может не надо, если они через сервер общие). 
- Services: - ApiService / HttpClient wrappers – можно иметь общий сервис для http, но Angular HttpClient и так достаточен
- LoggingService – вдруг нужно логировать ошибки.
- DeviceService – может, чтобы собрать info об устройстве (для сессий).
- Guard и Interceptor: - AuthGuard – защищает маршруты /vault/ от неавторизованных. 
- HttpInterceptor – подставляет JWT Authorization header ко всем запросам, обрабатывает 401 ошибки (например, запускает refresh token, если есть).
- State Management: Для простоты можно через сервисы с RxJS. Если масштабировать – можно NgRx, но возможно избыточно.
- UI Framework: Можно использовать PrimeNG для консистентного UI, диалогов (например, диалог подтверждения удаления, диалог ввода 2FA). 
- Angular-client обеспечит Validation на клиенте (приятное: например, предупреждение о слабом пароле при регистрации сразу, подсветка полей).
- Модуль 2FA – например, QR-код для подключения TOTP (можно генерировать прямо в browser используя QR library).
- Модуль WebAuthn* – вызов navigator.credentials.create/get из TS-кода. Angular сервис WebAuthnService, который общается с /auth/webauthn endpoints.
4.2.2. Node.js/Express-сервер:
- Основные части:
 - Маршруты (Routes) и Контроллеры: - /auth маршруты: 
- POST /auth/register -> AuthController.register() - POST /auth/login -> AuthController.login()
- POST /auth/logout -> AuthController.logout() - POST /auth/refresh -> AuthController.refresh() (если JWT)
- POST /auth/totp/enable -> привязать TOTP (генерирует секрет, выдаёт, сохраняет) 
- POST /auth/totp/verify -> при логине проверка 
- POST /auth/webauthn/register (начало, выдача challenge), - POST /auth/webauthn/response (финал регистрации), - POST /auth/webauthn/authenticate (начало входа), 
- POST /auth/webauthn/verify (проверка ответа).
 - Возможно объединить умнее, но можно и так. - /vault маршруты: - GET /vault/items -> VaultController.listItems() – возвращает все записи текущего пользователя (шифр). 
- POST /vault/items -> VaultController.createItem()– принимает шифр. Создает запись в БД. 
-GET /vault/items/:id-> get one (может и не нужно, можно сразу все иметь). 
-PUT /vault/items/:id-> обновить запись. 
-DELETE /vault/items/:id-> удалить запись. 
-/sessions маршруты: 
-GET /sessions-> SessionController.list() – список активных сессий/устройств (из коллекции Sessions). -DELETE /sessions/:sessionId-> logout that session. 
-DELETE /sessions/others-> logout all others. - ВозможноGET /devicesтоже, но можно объединить понятие device & session, у нас device info внутри session. -/audit-logмаршрут: 
-GET /audit-log(для пользователя – его события.
-/user: 
-GET /user/profile(email, настройки), 
-POST /user/password(смена пароля), 
-POST /user/enable-2fa. 

- **Middleware**: 
-authMiddleware– проверяет токен/сессию на всех маршрутах /vault, /sessions, etc. Если JWT: проверяет подпись, валидность, ставит req.user (с ID, ролями). Если session cookie: ищет в DB. 
-rateLimitMiddleware– например, на /auth/login и /auth/register, ограничить частоту с IP. 
-csrfMiddleware– если используем CSRF tokens, проверять их. -helmet– Express middeware для установки security заголовков (CSP можно через helmet.contentSecurityPolicy). 
-errorHandler– централизованный, чтобы не утекали трасы и инфо. -loggingMiddleware– например, morgan для логов запросов (но нужно фильтровать, не логировать чувствительные). 

- **Сервисы (внутри backend)**: 
-UserService– обертка над User-моделью. Например, createUser (будет хешировать пароль перед сохранением). 
-AuthService– функции: verifyPassword (Argon2 verify), generateJWT, verifyJWT, generateOTP, verifyOTP, generateChallenge (webauthn). 
-VaultService– может не нужен, т.к. сервер не делает крипто, просто DB calls. Но можно, например: getItemsByUser(userId), createItem(userId, data), markDelete etc. 
-SessionService– записи о сессиях: saveSession(userId, token/device info), getSessionsByUser, deleteSession. 
-AuditService– сохранение событий (login fail, login success, new device). -EmailService– если отправляем email OTP или alerts, капсулировать nodemailer, шаблоны. 
-WebAuthnService– (optional) – генерить challenge, хранить его временно (в сессии или DB) до ответа, проверять signature (есть libs like @simplewebauthn/server). 

- **Модели (Model)**: 
- User (schema: email, passwordHash, salt, 2faEnabled, totpSecret(enc), webauthnCredentials[], ...). 
- VaultItem (schema: userId, data_encrypted (может быть binary or base64), maybe fields like title_hmac or something if doing search). 
- Session (schema: sessionId/tokenId, userId, deviceInfo (agent, IP, location), createdAt, lastActiveAt). - VaultItemVersion (schema: itemId, userId, version, data_encrypted, timestamp) – or embed in VaultItem as versions: []. 
- AuditLog (schema: userId, action, timestamp, details). 

- **Безопасность**: 
- Пароли хэшируются с Argon2 (в Node можно использовать библиотекуargon2 или bcrypt. 
- При логине: Argon2.verify(hash, password) (но в нашем случае, password не отправляется, hash verification, or we do separate salt & derivation). 
- JWT secret – environment variable, 256-bit random. - TLS termination – Node.js может сам или за Nginx, тут не критично, но Node 18+ умеет HTTP/2 TLS. 
- Express должен быть настроен, чтобы не отдавать stack trace, hide X-Powered-By (helmet does). - Логирование: - Лог успешных/неуспешных входов (в audit).
 - Лог ошибок сервера (500 и тп) – в stderr + monitoring.

4.2.4. Браузерное расширение: - Структурно расширение состоит из: 
- Background script (фонового скрипта): работает постоянно (пока браузер открыт). Он управляет данными и слушает события (горячие клавиши, сообщения от content scripts, toolbar icon clicks). Background хранит, скажем, зашифрованный кэш или расшифрованные данные (в памяти). 
- Content scripts: встраиваются в страницы (в те, что разрешили в манифесте, обычно http:///). Они имеют доступ к DOM страницы и могут найти поля, вставить значения. Content script, обнаружив форму, шлет сообщение background: "On site example.com found login form". Background проверяет: "у пользователя есть запись для example.com?" Если да и пользователь разблокировал vault, background отдает content script необходимые данные (логин, пароль) – возможно, зашифр. (но contentscript – мы ему доверяем, это наш код). Он вставляет значения. 
- Popup script: HTML/JS, отображающаяся при клике на иконку расширения. В popup – UI для поиска паролей, кнопки копировать, автофилл, настройка (например, "заблокировать расширение", "открыть веб-версию"). 
- Options page: если нужна, можно сделать, где user может ввести URL API (если self-host) или настроить горячие клавиши. - Взаимодействие: - При первой установке расширения или при первом использовании, background script возможно запускает UI логина (можно прямо в popup: user enters master-password in popup). 
- Background отправляет login request к серверу (как SPA) и получает токен (или uses cookies if same domain). - Background сохраняет auth token (in memory or chrome.storage.local encrypted). 
- Фоновый процесс держит расшифрованное хранилище в памяти для быстрого доступа. 
- События скрипта контента запускают фоновое использование данных. - Расширение также должно отслеживать такие события, как закрытие браузера (для очистки памяти) или таймеры блокировки (если браузер неактивен, то очистить данные). - Безопасность:
- Обмен сообщениями между контентом и фоном изолирован от внешнего мира, но убедитесь, что не обрабатываются сообщения от других расширений (они могут отправлять, если знают ID расширения? Есть некоторые ограничения). 
5. Проєктування бази даних (Проектирование базы данных)
В системе используется база данных MongoDB для хранения всей постоянной информации. Проектирование БД направлено на обеспечение целостности данных, быстрого доступа по необходимым ключам и, главное, безопасного хранения (минимизация открытой информации). Ниже описаны основные коллекции и их структура, а также примечания по безопасности хранения.
5.1. Структура колекцій та полів (Структура коллекций и полей)
Колекція users (пользователи): хранит учетные записи пользователей.
 - Поля:
 - _id: унікальний ідентифікатор (ObjectId). Используется как основной ключ. 
- email: рядок, унікальний. Электронная почта пользователя для логина и коммуникаций. 
- passwordHash: рядок/Buffer. Хеш пароля пользователя, полученный KDF (Argon2id). Формат может содержать параметры
- kdf: (опционально) объект или поля, описывающие, какой алгоритм KDF применен и параметры (если не включено в passwordHash). 
- vaultKey: Buffer, optional. Если реализуется схема с отдельным ключом для шифрования хранилища: этот ключ (симметричный 256 бит) шифруется мастер-паролем и хранится здесь. 
- twoFactorEnabled: Boolean, указывает, включена ли 2FA.
- totpSecretEnc: строка/Buffer. Секретный ключ для TOTP в зашифрованном виде. Шифрование может быть сделано на мастер-ключ пользователя (который есть только в памяти клиента), или на серверный общий ключ. 
- webauthnCredentials: массив поддокументов с информацией об аппаратных ключах:
- credId: Buffer (идентификатор ключа, уникальный, обычно <= 256 байт)
- publicKey: Buffer (публичный ключ, CBOR-encoded или raw)
- type: String (тип ключа, например "public-key")
- regDate: Date (когда зарегистрирован)
- counter: Number (счетчик, для U2F ключей)

Колекція vaultItems: хранит записи (учетные данные) пользователей.
- Поля:
- _id: ObjectId (генерируется базой).
- userId: ObjectId, ссылка на пользователя-владельца
- type – тип записи (заметка/пароль, от этого показываем тот или иной layout)
- data: BinData или String. Основное содержимое записи в зашифрованном виде. Он сериализуется (JSON.stringify), затем шифруется. Получается, например, base64 строка или бинарь + tag. Можно сохранить в поле data как двоичные данные (BinData) или base64 строку. 
Коллекція sessions: хранит активные сессии/устройства.
- Поля:
- _id: либо ObjectId, либо можно использовать идентификатор сессии (если JWT, у токена jti).
- userId: ObjectId
- device: строка (например, "Chrome on Windows 10", можно формировать из user agent)
- ip: строка (IPv4/IPv6)
- userAgent: строка (полный агент, можно хранить для логов),
- createdAt: Date,
- lastActiveAt: Date (можно обновлять при каждом запросе или раз в N минут
- valid: Boolean (false если пользователь логаутнулся или сессия отозвана).
- token: (опционально) строка refresh-токена hash. Если JWT, access token хранить не нужно (он короткоживущий), но refresh (долгоживущий) можно хранить хеш

Коллекція auditLogs (если будем)
 - Поля:
- _id: ObjectId
- userId: ObjectId (может быть null, если событие глобальное)
- action: String (enum, e.g., "LOGIN_FAIL", "LOGIN_SUCCESS", "ITEM_CREATE", "ITEM_DELETE", "2FA_ENABLED", etc),
- timestamp: Date
- details: объект или строка (IP, maybe itemId truncated).
- Индексы: (userId, timestamp) – для запросов по пользователю. 
5.2. Дані у відкритому вигляді vs зашифрованому (Данные в открытом виде vs зашифрованном)
Індекси, унікальні обмеження, ключі пошуку (Indices, unique constraints, search keys):
•	users.email: уникальный индекс. Это ключ поиска при входе.
•	vaultItems.userId: не уникальный (много записей на user), но обязательно индексированный. Часто будем выборку по userId делать.
•	vaultItems._id: primary key default.
•	vaultItems.titleHash: (если реализуем) – индекс для поиска по названию. Но можно обойтись без.
•	sessions.userId: индекс.
•	sessions.tokenId: если JWT, jti unique.
•	auditLogs.userId: индекс (если нужно быстро достать все события конкретного пользователя).
•	auditLogs.action: возможно индекс по типу события и времени, если хотим выгрузить, например, все попытки логина в системе (но у нас нет административного интерфейса, так что не обязательно).
•	vaultItemVersions.itemId: индекс.
Unique constraints: - Email – unique (как сказано). 
Обмеження цілісності: - Mongo не поддерживает прямо foreign keys, но логически: vaultItem.userId должен ссылаться на существующего user. Обеспечивается приложением: при удалении пользователя, нужно каскадом удалить его записи (либо, лучше, не позволять удаления учеток без сильной необходимости). 
6. Інтерфейси (API)
Серверна частина надає набір REST API ендпоінтів, за допомогою яких клієнтські додатки (Angular SPA, браузерне розширення) взаємодіють із системою. Нижче перелічено основні маршрути API, їх призначення, а також формат запитів і відповіді (у форматі JSON). Всі URL наведені відносно базового шляху API (наприклад, https://passwordmanager.example/api/...).
10.1. Ендпоінти авторизації (Auth API)
POST /auth/register – Реєстрація нового користувача.
Запит: очікує JSON з даними нового акаунта:
{
  "email": "user@example.com",
  "masterPassword": "VeryStrongPassword123!",
  "totpSetup": false
}
- Поле totpSetup (опціонально) може вказувати, чи бажає користувач відразу налаштувати 2FA. Якщо true, сервер у відповіді може одразу повернути секрет для налаштування TOTP. Відповідь (успіх): статус 201 Created, тіло:
{
  "userId": "641e5e8f...abcdef",
  "message": "User registered successfully"
}
- Сервер створює обліковий запис, хешує пароль (Argon2id) і зберігає. Якщо totpSetup=true, то додатково генерує секрет TOTP:
{
  "userId": "...",
  "totpSecret": "JBSWY3DPEHPK3PXP",    // баз32 секрет для Google Authenticator (приклад)
  "totpQrImage": "data:image/png;base64,iVBORw0KG..."  // QR-код для зручності (може бути URL або base64)
}
- У разі помилки (напр. email вже зайнятий) – статус 409 Conflict, тіло: { "error": "Email already in use" }.
POST /auth/login – Вхід користувача.
Запит: JSON з обліковими даними:
{
  "email": "user@example.com",
  "masterPassword": "VeryStrongPassword123!"
}
- За необхідності можуть бути дод. поля, напр. webauthnChallengeResponse або totpCode, якщо 2FA. Відповідь (без 2FA): статус 200 OK, тіло містить токени сесії:
{
  "accessToken": "<jwt_access_token>",
  "refreshToken": "<jwt_refresh_token>",
  "tokenType": "Bearer",
  "expiresIn": 3600,
  "user": {
    "userId": "641e5e8f...abcdef",
    "email": "user@example.com",
    "twoFactorEnabled": true
  }
}
- Якщо увімкнено двофакторну авторизацію, і сервер це знає (twoFactorEnabled=true), то успішний пароль повертає відповідь з вимогою 2FA:
{
  "require2FA": true,
  "method": "TOTP" 
}
Клієнт тоді повинен викликати POST /auth/2fa/verify (умовно) з одноразовим кодом:
{
  "userId": "641e5e8f...abcdef",
  "otp": "123456"
}
на що сервер поверне вже токени, як вище, або помилку. - У разі використання WebAuthn як 2FA, сервер може надіслати:
{
  "require2FA": true,
  "method": "WebAuthn",
  "webauthnOptions": { ... }   // Challenge та параметри для navigator.credentials.get()
}
Клієнт через WebAuthn API отримує підпис, і надсилає на POST /auth/webauthn/verify:
{
  "userId": "...",
  "credentialId": "...", 
  "clientDataJSON": "...", 
  "authenticatorData": "...", 
  "signature": "..."
}
Якщо перевірка успішна – видаються токени. - Помилки: 401 Unauthorized для невірного пароля або 2FA коду (можна окремо: {"error":"Invalid credentials"}), 404 якщо email не знайдено.
POST /auth/logout – Вихід із системи (завершення поточної сесії).
Запит: не потребує тіла (ідентифікація по токену чи сесії). Відповідь: 200 OK, тіло: { "message": "Logged out" }.
- Сервер верифікує токен, робить його невалідним (вносить у чорний список або видаляє сесію).
- Може застосовуватися як для web, так і для extension.
POST /auth/refresh – Оновлення токена доступу.
Запит: надсилається refreshToken (якщо не у cookie). Формат:
{
  "refreshToken": "<jwt_refresh_token>"
}
Відповідь: 200 OK, новий accessToken:
{
  "accessToken": "<new_access_token>",
  "expiresIn": 3600
}
- Помилка 401, якщо refresh недійсний або протермінований.
POST /auth/webauthn/register – Початок реєстрації апаратного ключа (WebAuthn).
Запит: несе userId (або береться з токена). Відповідь: Challenge і параметри для ключа:
{
  "challenge": "<random base64>",
  "rp": { "name": "Our Password Manager" },
  "user": { "id": "<userId_in_binary>", "name": "user@example.com", "displayName": "User" },
  "pubKeyCredParams": [ { "alg": -7, "type": "public-key" }, ... ],
  "attestation": "direct"
}
(Це фактично PublicKeyCredentialCreationOptions). Клієнт (браузер) викликає navigator.credentials.create(options). Потім клієнт надсилає на POST /auth/webauthn/register/finish (або /verify) результати:
{
  "attestationObject": "<base64>",
  "clientDataJSON": "<base64>"
}
Сервер перевіряє, зберігає публічний ключ, видає 200 OK { "credentialId": "<base64>" } або редиректить. (Протокол WebAuthn досить складний; ми наводимо спрощений вигляд).
GET /auth/status (можливо) – перевірка валідності токена. Повертає { "authenticated": true, "user": {...} } або 401. (Це зручно для клієнта при старті).
6.2. Ендпоінти сховища (Vault API)
Ці інтерфейси відповідають за операції з паролями та пов'язаними даними.
GET /vault/items – Отримати всі записи поточного користувача.
Запит: не потребує параметрів (окрім токена авторизації).
Відповідь: 200 OK, тіло – масив об'єктів:
[
  {
    "itemId": "6420e8...12345",
    "userId": "641e5e...abcdef",
    "data": "Base64EncodedCiphertext==", 
    "lastModified": "2025-03-20T12:34:56Z"
  },
  {
    "itemId": "...",
    "userId": "...",
    "data": "Base64EncodedCiphertext2==", 
    "lastModified": "2025-03-18T09:10:11Z"
  }
]
- Поле data містить зашифровану інформацію (наприклад, AES-GCM cipher output, закодований в Base64 або Hex). Клієнт повинен його розшифрувати своїм ключем.
POST /vault/items – Створити новий запис в сховищі.
Запит: JSON з даними нового запису. Але увага: конфіденційні поля мають бути вже зашифровані на клієнті! Тож формат запиту може бути такий:
{
  "data": "Base64Ciphertext==", 
  "folder": "Finance",
  "tags": ["bank", "creditcard"]
}
- Тут data – результат шифрування об'єкта, що містить login/password/note.
- folder та tags – необов'язкові метадані (можуть бути відкритими або зашифрованими; у цьому прикладі припустимо відкриті для простоти пошуку). Відповідь: 201 Created, тіло:
{
  "itemId": "6420e8...7890ab",
  "message": "Item created"
}
- Сервер зберігає запис: генерує _id, ставить userId з токена, фіксує час створення. - Може також повернути весь об'єкт, включаючи lastModified.
GET /vault/items/{id} – Отримати конкретний запис.
- Не є обов'язковим, бо клієнт може мати всі з /items. Але для архітектури REST повноти, можна. - Відповідь:
{
  "itemId": "...",
  "userId": "...",
  "data": "Base64Ciphertext==",
  "lastModified": "2025-03-20T12:34:56Z"
}
(Якщо запис не належить користувачу – 404 або 403.)
PUT /vault/items/{id} – Оновлення (редагування) запису.
Запит: JSON з новими значеннями. Формат аналогічний POST, але може містити тільки змінені поля:
{
  "data": "NewEncryptedDataBase64==",
  "folder": "Finance",
  "tags": ["bank"]
}
- Усі дані, які змінено (особливо пароль), мають бути зашифровані на клієнті. - Сервер знайде запис за {id} та userId (щоб виключити чужий), оновить data, folder, tags, а також збільшить version та lastModified. Відповідь: 200 OK,
{ "message": "Item updated", "itemId": "..." }
- За необхідності сервер може повернути новий lastModified та version:
{ 
  "message": "Item updated", 
  "itemId": "...", 
  "lastModified": "2025-03-30T08:00:00Z", 
  "version": 3 
}
Це корисно для клієнта, щоб відразу мати актуальні метадані.
DELETE /vault/items/{id} – Видалити запис.
Запит: без тіла. Після аутентифікації, сервер видаляє або позначає видаленим запис з заданим ID, якщо він належить користувачу.
Відповідь: 200 OK, { "message": "Item deleted", "itemId": "{id}" }.
- Якщо запис з таким ID не знайдено для цього юзера – 404.
GET /vault/backup – Експорт всього сховища (резервна копія).
- Запит: може містити параметр format (наприклад, json за замовчуванням). - Відповідь: 200 OK, Content-Type: application/json (чи application/octet-stream). Тіло – JSON, що включає всі записи користувача (вже зашифровані, аналогічно /vault/items). Приклад:
{
  "userId": "641e5e...abcdef",
  "exportedAt": "2025-03-20T13:00:00Z",
  "items": [
    { "itemId": "6420e8...12345", "data": "Base64Ciphertext1==", "lastModified": "..." },
    { "itemId": "6420e8...67890", "data": "Base64Ciphertext2==", "lastModified": "..." }
  ]
}
- Такий файл є зашифрованим контейнером (кожен запис окремо зашифрований). - Зауваження: якщо потрібно, можна додатково зашифрувати весь JSON певним ключем (наприклад, майстер-ключем) перед відправкою, щоб отриманий файл був у форматі "Encrypted Backup". 
POST /vault/restore – Імпорт (відновлення з резервної копії).
Запит: JSON, що містить дані з резервної копії, або файл. Наприклад:
{
  "items": [
    { "data": "Base64Ciphertext1==", "lastModified": "...", "folder": "Finance" },
    { "data": "Base64Ciphertext2==", "lastModified": "...", "folder": "Social" }
  ]
}
- Сервер проходить по кожному елементу, створює новий запис у БД, прив'язаний до userId. - За бажанням, можна зберегти оригінальні lastModified (але це може заплутати, можливо краще ставити поточний час, а старі часи лишати в історії). Відповідь: 201 Created або 207 Multi-Status (якщо частково?). Простий шлях: 201 з повідомленням:
{ "message": "Vault restored: 15 items imported" }
- Помилки: якщо формат не валідний – 400 Bad Request. Якщо якісь записи дублюються з існуючими – можна створити дублікати, або оновлювати. Поведінка має бути узгоджена: можливо, параметр mode: "merge"|"overwrite"|"duplicate".
6.3. Ендпоінти керування сесіями та пристроями
GET /sessions – Отримати список активних сесій/пристроїв поточного користувача.
Відповідь: 200 OK, наприклад:
[
  {
    "sessionId": "df8a9c...abc123",
    "device": "Chrome on Windows",
    "ip": "203.0.113.42",
    "lastActive": "2025-03-20T12:00:00Z",
    "current": true
  },
  {
    "sessionId": "a34b21...def456",
    "device": "Firefox on Android",
    "ip": "198.51.100.7",
    "lastActive": "2025-03-18T08:30:00Z",
    "current": false
  }
]
- current: true показує, яка сесія відповідає поточному токену запиту. - Цей список відображатиметься користувачу для контролю (в налаштуваннях безпеки).
DELETE /sessions/{sessionId} – Вийти з певної сесії (примусовий логаут).
- Якщо sessionId відповідає поточній – це еквівалент /auth/logout. - Якщо це інша сесія: сервер перевіряє, що sessionId належить userId. Знищує її. - Відповідь: 200 OK, { "message": "Session terminated", "sessionId": "..."} - Після цього відповідний пристрій при спробі зробити API запит отримає 401 (токен відкликано).
DELETE /sessions (з параметром) – Масове завершення сесій.
Можливі варіанти: - DELETE /sessions?all=true – вихід на всіх пристроях (крім поточного). 
6.4. Ендпоінти журналу аудиту
GET /audit-log – Отримати журнал безпекових подій для свого акаунта.
Відповідь: 200 OK, масив подій (останні N):
[
  { "timestamp": "2025-03-20T12:34:56Z", "action": "LOGIN_SUCCESS", "ip": "203.0.113.5", "userAgent": "Chrome/..." },
  { "timestamp": "2025-03-19T08:00:00Z", "action": "LOGIN_FAILURE", "ip": "203.0.113.5" },
  { "timestamp": "2025-03-18T07:10:11Z", "action": "ITEM_CREATE", "itemId": "6420e8...12345", "itemTitle": "Email Account" }
]
- Тут для зручності itemTitle може бути записаний при створенні (нешифрований) у лог – але краще уникати цього (щоб навіть у логах не світити назву; можна просто itemId або 
Приклади використання API у робочому сценарії:
•	Реєстрація та вхід: Користувач реєструється через /auth/register. Потім виконує /auth/login. При успішному вході отримує accessToken (наприклад JWT) і refreshToken. Клієнт зберігає accessToken (в пам'яті) і починає сесію. Надалі кожен запит до /vault включає заголовок Authorization: Bearer <accessToken>. Якщо токен протермінувався, клієнт викликає /auth/refresh із refreshToken (який може бути HttpOnly cookie) і отримує новий.
•	Отримання і відображення паролів: Клієнт при запуску (або при переході у vault розділ) викликає /vault/items, отримує масив з data полями. Кожен data розшифровує (використавши майстер-ключ у пам'яті), відображає список (може тільки назви, які були всередині зашифрованого об'єкта, тепер вже відомі клієнту).
•	Додавання нового пароля: Користувач натискає "Add". Клієнт збирає поля (назва, логін, пароль, примітка), формує об'єкт, шифрує його (AES-256-GCM, ключ – майстер-ключ), отримує ciphertext (base64). Відправляє на сервер POST /vault/items із цим ciphertext. Сервер відповідає itemId. Клієнт присвоює локально новому запису цей itemId, може одразу додати до списку відображення.
•	Редагування пароля: Аналогічно: клієнт бере існуючий об'єкт, підставляє нові значення, шифрує, шле PUT /vault/items/id. Сервер відповідає успіх – клієнт оновлює у себе.
•	Вихід з усіх пристроїв: Користувач підозрює щось – відкриває список сесій (/sessions), бачить підозрілий пристрій, тисне "Log out all". Клієнт викликає DELETE /sessions?all=true. Сервер знищує всі сесії. Клієнт (поточний) теж отримує 200, але фактично його refreshToken теж відкликано – він мусить увійти знову (можна навіть одразу перенаправити на /login).
•	Використання розширення: Розширення після встановлення показує форму входу (або пропонує відкрити веб для логіну і отримати токен). При вході через розширення, воно теж звертається до /auth/login і отримує свої токени. Потім розширення викликає /vault/items так само і працює автономно.
•	Налаштування 2FA: Користувач у профілі тисне "Enable 2FA". Клієнт викликає POST /auth/totp/enable (наприклад), сервер генерує секрет і відповідає з totpSecret та, можливо, QR-кодом (як data URL). Клієнт показує код користувачу. Користувач сканує в додатку, вводить перший згенерований код для перевірки. Клієнт відправляє цей код на /auth/totp/verify. Сервер підтверджує і увімк. twoFactorEnabled. В наступні логіни вже через require2FA flow.
7. Вимоги до журналювання, аудиту та моніторингу
7.1. Події, що підлягають журналюванню: Система повинна реєструвати в журналі (audit log) наступні категорії подій: 
- Події автентифікації:
- Успішний вхід користувача (LOGIN_SUCCESS) – з зазначенням ідентифікатора користувача, часу, IP-адреси та інформації про клієнтський пристрій/браузер. Якщо використовувався 2FA – відмітка про це (наприклад, "2FA: TOTP" чи "WebAuthn"). 
- Невдала спроба входу (LOGIN_FAILURE) – з зазначенням введеного логіна (email), часу, IP. Причина невдачі (невірний пароль, невірний 2FA код, заблокований акаунт тощо) може зазначатися, але обережно, щоб не полегшувати зловмиснику підбір (наприклад, не писати прямо "wrong password or wrong 2FA", можна код помилки). - Вихід користувача (LOGOUT) – фіксується, коли користувач явно виходить або сесія завершується примусово. Логується час, відмітка як ініційовано (користувачем чи системно).
- Реєстрація нового акаунта (USER_REGISTERED) – час, email (маскований, наприклад "u@example.com"), IP. 
- *Зміна пароля (PASSWORD_CHANGED) – час, userId, чи ініційовано користувачем (так) і з якого IP.
- Включення/відключення 2FA (2FA_ENABLED / 2FA_DISABLED) – час, userId. - Події роботи з сховищем:
- Створення нового запису (ITEM_CREATE) – час, userId, можливо, ідентифікатор запису. В лог можна не записувати деталі (назву чи інше) з міркувань секретності, але варто зазначити, що запис створено. Наприклад: User 123 created vault item id 456. 
- Редагування запису (ITEM_UPDATE) – час, userId, itemId. Можна зберігати і стару назву/значення? Ні, не треба в логах; історія версій зберігається окремо у БД, а в лог – лише факт. 
- Видалення запису (ITEM_DELETE) – час, userId, itemId. Якщо передбачена "Корзина", то буде дві події: видалення (поміщено у корзину) і остаточне видалення (PURGE). - Експорт/імпорт (VAULT_EXPORTED, VAULT_IMPORTED) – фіксується, коли користувач робить резервну копію або відновлює. Це рідкі події, але чутливі: експорт може означати, що користувач кудись переносить дані (чи зловмисник робить копію). Лог: час, userId, дія. 
